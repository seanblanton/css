'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _postcss = require('postcss');

var _reduceFunctionCall = require('reduce-function-call');

var _reduceFunctionCall2 = _interopRequireDefault(_reduceFunctionCall);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var reMap = /((?:map)\()(.*)(\))/;

var Parser = (function () {
  function Parser() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var maps = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, Parser);

    this.opts = opts;
    this.maps = maps;
  }

  /**
   * Parse and replace maps in declarations values.
   * @param {Object} decl
   */

  _createClass(Parser, [{
    key: 'processDecl',
    value: function processDecl(decl) {
      var _this = this;

      if (!reMap.test(decl.value)) return;

      decl.value = (0, _reduceFunctionCall2.default)(decl.value, 'map', function (body) {
        return _this.getValue(_postcss.list.comma(body));
      });
    }

    /**
     * Parse and proccess at-rules.
     * @param {Object} rule
     */

  }, {
    key: 'processAtRule',
    value: function processAtRule(rule) {
      if (rule.name === 'map') return this.replaceAtRuleBlock(rule);
      if (reMap.test(rule.params)) return this.replaceAtRuleParam(rule);
    }

    /**
     * Get and print at-rules map declarations.
     * @param {Object} rule
     */

  }, {
    key: 'replaceAtRuleBlock',
    value: function replaceAtRuleBlock(rule) {
      var map = this.getValue(_postcss.list.space(rule.params));

      Object.keys(map).forEach(function (prop) {
        rule.parent.insertBefore(rule, { prop: prop, value: map[prop] });
      });

      rule.remove();
    }

    /**
     * Parse and replace maps in at-rules parameters.
     * @param {Object} rule
     */

  }, {
    key: 'replaceAtRuleParam',
    value: function replaceAtRuleParam(rule) {
      var _this2 = this;

      rule.params = (0, _reduceFunctionCall2.default)(rule.params, 'map', function (body) {
        return _this2.getValue(_postcss.list.comma(body));
      });
    }

    /**
     * Get value from a deep nested object properties.
     * @param {Array} args
     * @return {*}
     */

  }, {
    key: 'getValue',
    value: function getValue(args) {
      var _args = _toArray(args);

      var name = _args[0];

      var props = _args.slice(1);

      var shortcutMap = this.useShortcutMap(name);

      if (shortcutMap) {
        name = shortcutMap;
        props = args;
      }

      return props.reduce(function (acc, prop) {
        return acc[prop];
      }, this.maps[name]);
    }

    /**
     * Get map name usable with the short syntax.
     * @param {String} name
     * @return {Boolean|String}
     */

  }, {
    key: 'useShortcutMap',
    value: function useShortcutMap(name) {
      if (name in this.maps) return false;
      if (this.opts.defaultMap in this.maps) return this.opts.defaultMap;
      var names = Object.keys(this.maps);
      if (names.length === 1) return names[0];
    }
  }]);

  return Parser;
})();

exports.default = Parser;